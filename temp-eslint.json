[{"filePath":"C:\\Users\\noutc\\Casskai\\src\\services\\automaticLetterageService.ts","messages":[{"ruleId":"no-await-in-loop","severity":1,"message":"Unexpected `await` inside a loop.","line":145,"column":26,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":150,"endColumn":8},{"ruleId":"no-await-in-loop","severity":1,"message":"Unexpected `await` inside a loop.","line":203,"column":30,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":207,"endColumn":8},{"ruleId":"no-await-in-loop","severity":1,"message":"Unexpected `await` inside a loop.","line":215,"column":13,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":215,"endColumn":45},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":290,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":290,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7902,7905],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7902,7905],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":291,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":291,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7947,7950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7947,7950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":298,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":298,"endColumn":29,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8147,8148],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Static async method 'getLetterageReport' has too many lines (131). Maximum allowed is 100.","line":693,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":823,"endColumn":4},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (825). Maximum allowed is 700.","line":701,"column":1,"nodeType":null,"messageId":"exceed","endLine":826,"endColumn":1},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":765,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":765,"endColumn":43},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":795,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":795,"endColumn":36},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":805,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":805,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LetterageRule as _LetterageRule, LetterageCriteria, LetterageMatch, FECEntry as _FECEntry } from '../types/accounting-import.types';\r\nimport { supabase } from '../lib/supabase';\r\n\r\n// Type alias to use LetterageRule without underscore in the code\r\ntype LetterageRule = _LetterageRule;\r\n\r\ninterface AccountingEntry extends Record<string, unknown> {\r\n  id?: string;\r\n  account?: string;\r\n  accountNumber?: string;\r\n  accountId?: string;\r\n  account_id?: string;\r\n  amount?: number;\r\n  debitAmount?: number;\r\n  creditAmount?: number;\r\n  debit_amount?: number;\r\n  credit_amount?: number;\r\n  date?: string;\r\n  reference?: string;\r\n  third_party?: string;\r\n  thirdParty?: string;\r\n  auxiliary_account?: string;\r\n  label?: string;\r\n  description?: string;\r\n  entryId?: string;\r\n  letterage?: string;\r\n  accounts?: {\r\n    id?: string;\r\n    number?: string;\r\n    name?: string;\r\n  } | Array<{\r\n    id?: string;\r\n    number?: string;\r\n    name?: string;\r\n  }>;\r\n  journal_entries?: {\r\n    id?: string;\r\n    date?: string;\r\n    reference?: string;\r\n    description?: string;\r\n    company_id?: string;\r\n  } | Array<{\r\n    id?: string;\r\n    date?: string;\r\n    reference?: string;\r\n    description?: string;\r\n    company_id?: string;\r\n  }>;\r\n}\r\n\r\ninterface LetterGroup {\r\n  letterCode: string;\r\n  date: string;\r\n  entriesCount: number;\r\n  totalAmount: number;\r\n}\r\n\r\n/**\r\n * Service de lettrage automatique des comptes\r\n */\r\nexport class AutomaticLetterageService {\r\n\r\n  /**\r\n   * Règles de lettrage prédéfinies\r\n   */\r\n  private static readonly DEFAULT_RULES: LetterageRule[] = [\r\n    {\r\n      id: 'clients_exact_amount',\r\n      name: 'Clients - Montant exact',\r\n      accountPattern: '411%',\r\n      criteria: [\r\n        { field: 'amount', exactMatch: true },\r\n        { field: 'date', daysWindow: 60 }\r\n      ],\r\n      tolerance: 0.01,\r\n      autoValidate: true\r\n    },\r\n    {\r\n      id: 'suppliers_exact_amount',\r\n      name: 'Fournisseurs - Montant exact',\r\n      accountPattern: '401%',\r\n      criteria: [\r\n        { field: 'amount', exactMatch: true },\r\n        { field: 'date', daysWindow: 90 }\r\n      ],\r\n      tolerance: 0.01,\r\n      autoValidate: true\r\n    },\r\n    {\r\n      id: 'clients_reference',\r\n      name: 'Clients - Référence facture',\r\n      accountPattern: '411%',\r\n      criteria: [\r\n        { field: 'reference', exactMatch: true },\r\n        { field: 'amount', tolerance: 0.05 }\r\n      ],\r\n      tolerance: 0.01,\r\n      autoValidate: false\r\n    },\r\n    {\r\n      id: 'bank_reconciliation',\r\n      name: 'Rapprochement bancaire',\r\n      accountPattern: '512%',\r\n      criteria: [\r\n        { field: 'amount', exactMatch: true },\r\n        { field: 'date', daysWindow: 5 }\r\n      ],\r\n      tolerance: 0.00,\r\n      autoValidate: true\r\n    }\r\n  ];\r\n\r\n  /**\r\n   * Lance le lettrage automatique pour une entreprise\r\n   */\r\n  static async performAutoLetterage(\r\n    companyId: string,\r\n    accountPattern?: string,\r\n    dateFrom?: string,\r\n    dateTo?: string\r\n  ): Promise<{\r\n    totalProcessed: number;\r\n    matched: number;\r\n    lettered: number;\r\n    results: Array<{\r\n      ruleId: string;\r\n      ruleName: string;\r\n      matches: LetterageMatch[];\r\n      autoValidated: number;\r\n    }>;\r\n  }> {\r\n    const rules = await this.getLetterageRules(companyId);\r\n    const filteredRules = accountPattern \r\n      ? rules.filter(rule => this.matchesPattern(rule.accountPattern, accountPattern))\r\n      : rules;\r\n\r\n    let totalProcessed = 0;\r\n    let totalMatched = 0;\r\n    let totalLettered = 0;\r\n    const results: Array<{ ruleId: string; ruleName: string; matches: LetterageMatch[]; autoValidated: number }> = [];\r\n\r\n    for (const rule of filteredRules) {\r\n      console.warn(`Processing rule: ${rule.name}`);\r\n      \r\n      const ruleResult = await this.processLetterageRule(\r\n        companyId, \r\n        rule, \r\n        dateFrom, \r\n        dateTo\r\n      );\r\n\r\n      totalProcessed += ruleResult.processed;\r\n      totalMatched += ruleResult.matches.length;\r\n      totalLettered += ruleResult.autoValidated;\r\n\r\n      results.push({\r\n        ruleId: rule.id,\r\n        ruleName: rule.name,\r\n        matches: ruleResult.matches,\r\n        autoValidated: ruleResult.autoValidated\r\n      });\r\n    }\r\n\r\n    return {\r\n      totalProcessed,\r\n      matched: totalMatched,\r\n      lettered: totalLettered,\r\n      results\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Traite une règle de lettrage spécifique\r\n   */\r\n  private static async processLetterageRule(\r\n    companyId: string,\r\n    rule: LetterageRule,\r\n    dateFrom?: string,\r\n    dateTo?: string\r\n  ): Promise<{\r\n    processed: number;\r\n    matches: LetterageMatch[];\r\n    autoValidated: number;\r\n  }> {\r\n    // Récupération des écritures non lettrées pour ce pattern de compte\r\n    const unlettered = await this.getUnletteredEntries(\r\n      companyId, \r\n      rule.accountPattern, \r\n      dateFrom, \r\n      dateTo\r\n    );\r\n\r\n    if (unlettered.length === 0) {\r\n      return { processed: 0, matches: [], autoValidated: 0 };\r\n    }\r\n\r\n    // Groupement par compte pour optimiser le traitement\r\n    const entriesByAccount = this.groupEntriesByAccount(unlettered);\r\n    const matches: LetterageMatch[] = [];\r\n    let autoValidated = 0;\r\n\r\n    for (const [accountId, entries] of entriesByAccount) {\r\n      const accountMatches = await this.findMatchesForAccount(\r\n        accountId, \r\n        entries, \r\n        rule\r\n      );\r\n\r\n      matches.push(...accountMatches);\r\n\r\n      // Auto-validation si configurée\r\n      if (rule.autoValidate) {\r\n        for (const match of accountMatches) {\r\n          if (match.confidence >= 0.9 && match.difference <= rule.tolerance) {\r\n            await this.applyLetterage(match);\r\n            autoValidated++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      processed: unlettered.length,\r\n      matches,\r\n      autoValidated\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Récupère les écritures non lettrées\r\n   */\r\n  private static async getUnletteredEntries(\r\n    companyId: string,\r\n    accountPattern: string,\r\n    dateFrom?: string,\r\n    dateTo?: string\r\n  ): Promise<Array<{\r\n    id: string;\r\n    accountId: string;\r\n    accountNumber: string;\r\n    date: string;\r\n    reference: string;\r\n    description: string;\r\n    debitAmount: number;\r\n    creditAmount: number;\r\n    thirdParty?: string;\r\n    entryId: string;\r\n  }>> {\r\n    let query = supabase\r\n      .from('journal_entry_items')\r\n      .select(`\r\n        id,\r\n        account_id,\r\n        debit_amount,\r\n        credit_amount,\r\n        description,\r\n        auxiliary_account,\r\n        letterage,\r\n        accounts!inner (id, number, name),\r\n        journal_entries!inner (id, date, reference, description)\r\n      `)\r\n      .eq('journal_entries.company_id', companyId)\r\n      .is('letterage', null) // Non lettrées\r\n      .like('accounts.number', accountPattern.replace('%', '*'));\r\n\r\n    if (dateFrom) query = query.gte('journal_entries.date', dateFrom);\r\n    if (dateTo) query = query.lte('journal_entries.date', dateTo);\r\n\r\n    const result = await query.order('journal_entries.date');\r\n\r\n    if (!result.data) return [];\r\n\r\n    return result.data.map((item: AccountingEntry) => ({\r\n      id: item.id as string,\r\n      accountId: item.account_id as string,\r\n      accountNumber: (item.accounts as { number?: string })?.number as string,\r\n      date: (item.journal_entries as { date?: string })?.date as string,\r\n      reference: (item.journal_entries as { reference?: string })?.reference || '',\r\n      description: item.description || (item.journal_entries as { description?: string })?.description || '',\r\n      debitAmount: item.debit_amount || 0,\r\n      creditAmount: item.credit_amount || 0,\r\n      thirdParty: item.auxiliary_account as string,\r\n      entryId: (item.journal_entries as { id?: string })?.id as string\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Groupe les écritures par compte\r\n   */\r\n  private static groupEntriesByAccount(entries: AccountingEntry[]): Map<string, any[]> {\r\n    const groups = new Map<string, any[]>();\r\n    \r\n    entries.forEach(entry => {\r\n      const accountId = entry.accountId;\r\n      if (!groups.has(accountId)) {\r\n        groups.set(accountId, []);\r\n      }\r\n      groups.get(accountId)!.push(entry);\r\n    });\r\n\r\n    return groups;\r\n  }\r\n\r\n  /**\r\n   * Trouve les correspondances pour un compte donné\r\n   */\r\n  private static async findMatchesForAccount(\r\n    accountId: string,\r\n    entries: AccountingEntry[],\r\n    rule: LetterageRule\r\n  ): Promise<LetterageMatch[]> {\r\n    const matches: LetterageMatch[] = [];\r\n\r\n    // Séparation débit/crédit\r\n    const debits = entries.filter(e => e.debitAmount > 0);\r\n    const credits = entries.filter(e => e.creditAmount > 0);\r\n\r\n    // Recherche de correspondances 1:1 (exact)\r\n    const exactMatches = this.findExactMatches(debits, credits, rule);\r\n    matches.push(...exactMatches);\r\n\r\n    // Recherche de correspondances multiples (1:n, n:1, n:n)\r\n    if (rule.criteria.some(c => !c.exactMatch)) {\r\n      const multipleMatches = await this.findMultipleMatches(debits, credits, rule);\r\n      matches.push(...multipleMatches);\r\n    }\r\n\r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Recherche de correspondances exactes 1:1\r\n   */\r\n  private static findExactMatches(\r\n    debits: AccountingEntry[],\r\n    credits: AccountingEntry[],\r\n    rule: LetterageRule\r\n  ): LetterageMatch[] {\r\n    const matches: LetterageMatch[] = [];\r\n    const usedCredits = new Set<string>();\r\n\r\n    debits.forEach(debit => {\r\n      credits.forEach(credit => {\r\n        if (usedCredits.has(credit.id)) return;\r\n\r\n        const match = this.evaluateMatch([debit], [credit], rule);\r\n        if (match && match.confidence >= 0.8 && match.difference <= rule.tolerance) {\r\n          matches.push(match);\r\n          usedCredits.add(credit.id);\r\n        }\r\n      });\r\n    });\r\n\r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Recherche de correspondances multiples\r\n   */\r\n  private static async findMultipleMatches(\r\n    debits: AccountingEntry[],\r\n    credits: AccountingEntry[],\r\n    rule: LetterageRule\r\n  ): Promise<LetterageMatch[]> {\r\n    const matches: LetterageMatch[] = [];\r\n\r\n    // Correspondance n:1 (plusieurs débits pour un crédit)\r\n    credits.forEach(credit => {\r\n      const combinations = this.findDebitCombinations(debits, credit.creditAmount, rule.tolerance);\r\n      combinations.forEach(combination => {\r\n        const match = this.evaluateMatch(combination, [credit], rule);\r\n        if (match && match.confidence >= 0.7) {\r\n          matches.push(match);\r\n        }\r\n      });\r\n    });\r\n\r\n    // Correspondance 1:n (un débit pour plusieurs crédits)\r\n    debits.forEach(debit => {\r\n      const combinations = this.findCreditCombinations(credits, debit.debitAmount, rule.tolerance);\r\n      combinations.forEach(combination => {\r\n        const match = this.evaluateMatch([debit], combination, rule);\r\n        if (match && match.confidence >= 0.7) {\r\n          matches.push(match);\r\n        }\r\n      });\r\n    });\r\n\r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Trouve les combinaisons de débits qui correspondent à un montant\r\n   */\r\n  private static findDebitCombinations(\r\n    debits: AccountingEntry[],\r\n    targetAmount: number,\r\n    tolerance: number\r\n  ): AccountingEntry[][] {\r\n    const combinations: AccountingEntry[][] = [];\r\n    const maxItems = Math.min(debits.length, 5); // Limite pour éviter l'explosion combinatoire\r\n\r\n    for (let size = 2; size <= maxItems; size++) {\r\n      const combos = this.generateCombinations(debits, size);\r\n      \r\n      combos.forEach(combo => {\r\n        const total = combo.reduce((sum, item) => sum + item.debitAmount, 0);\r\n        if (Math.abs(total - targetAmount) <= tolerance) {\r\n          combinations.push(combo);\r\n        }\r\n      });\r\n    }\r\n\r\n    return combinations;\r\n  }\r\n\r\n  /**\r\n   * Trouve les combinaisons de crédits qui correspondent à un montant\r\n   */\r\n  private static findCreditCombinations(\r\n    credits: AccountingEntry[],\r\n    targetAmount: number,\r\n    tolerance: number\r\n  ): AccountingEntry[][] {\r\n    const combinations: AccountingEntry[][] = [];\r\n    const maxItems = Math.min(credits.length, 5);\r\n\r\n    for (let size = 2; size <= maxItems; size++) {\r\n      const combos = this.generateCombinations(credits, size);\r\n      \r\n      combos.forEach(combo => {\r\n        const total = combo.reduce((sum, item) => sum + item.creditAmount, 0);\r\n        if (Math.abs(total - targetAmount) <= tolerance) {\r\n          combinations.push(combo);\r\n        }\r\n      });\r\n    }\r\n\r\n    return combinations;\r\n  }\r\n\r\n  /**\r\n   * Génère les combinaisons d'éléments\r\n   */\r\n  private static generateCombinations<T>(arr: T[], size: number): T[][] {\r\n    if (size > arr.length) return [];\r\n    if (size === 1) return arr.map(item => [item]);\r\n\r\n    const combinations: T[][] = [];\r\n    \r\n    for (let i = 0; i <= arr.length - size; i++) {\r\n      const rest = this.generateCombinations(arr.slice(i + 1), size - 1);\r\n      rest.forEach(combo => {\r\n        combinations.push([arr[i], ...combo]);\r\n      });\r\n    }\r\n\r\n    return combinations;\r\n  }\r\n\r\n  /**\r\n   * Évalue une correspondance potentielle\r\n   */\r\n  private static evaluateMatch(\r\n    debits: AccountingEntry[],\r\n    credits: AccountingEntry[],\r\n    rule: LetterageRule\r\n  ): LetterageMatch | null {\r\n    const totalDebit = debits.reduce((sum, item) => sum + item.debitAmount, 0);\r\n    const totalCredit = credits.reduce((sum, item) => sum + item.creditAmount, 0);\r\n    const difference = Math.abs(totalDebit - totalCredit);\r\n\r\n    if (difference > rule.tolerance * 2) return null; // Écart trop important\r\n\r\n    let confidence = 0;\r\n    const maxPoints = rule.criteria.length;\r\n    let points = 0;\r\n\r\n    // Évaluation selon les critères\r\n    rule.criteria.forEach(criterion => {\r\n      switch (criterion.field) {\r\n        case 'amount':\r\n          if (criterion.exactMatch && difference <= rule.tolerance) {\r\n            points += 1;\r\n          } else if (criterion.tolerance && difference <= criterion.tolerance * Math.max(totalDebit, totalCredit)) {\r\n            points += 0.8;\r\n          }\r\n          break;\r\n\r\n        case 'date': {\r\n          const avgDateDiff = this.calculateAverageDateDifference(debits, credits);\r\n          if (criterion.daysWindow && avgDateDiff <= criterion.daysWindow) {\r\n            points += 1 - (avgDateDiff / criterion.daysWindow) * 0.5;\r\n          }\r\n          break;\r\n        }\r\n\r\n        case 'reference':\r\n          if (this.hasMatchingReference(debits, credits, criterion.exactMatch || false)) {\r\n            points += 1;\r\n          }\r\n          break;\r\n\r\n        case 'thirdParty':\r\n          if (this.hasMatchingThirdParty(debits, credits)) {\r\n            points += 1;\r\n          }\r\n          break;\r\n      }\r\n    });\r\n\r\n    confidence = points / maxPoints;\r\n\r\n    // Bonus pour correspondance exacte\r\n    if (difference === 0) confidence += 0.1;\r\n\r\n    // Malus pour correspondances multiples\r\n    if (debits.length > 1 || credits.length > 1) confidence -= 0.1;\r\n\r\n    return {\r\n      debitEntries: debits.map(d => d.id),\r\n      creditEntries: credits.map(c => c.id),\r\n      difference,\r\n      confidence: Math.min(1, Math.max(0, confidence)),\r\n      letterCode: this.generateLetterCode()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calcule la différence moyenne de dates\r\n   */\r\n  private static calculateAverageDateDifference(debits: AccountingEntry[], credits: AccountingEntry[]): number {\r\n    if (debits.length === 0 || credits.length === 0) return Infinity;\r\n\r\n    let totalDiff = 0;\r\n    let count = 0;\r\n\r\n    debits.forEach(debit => {\r\n      credits.forEach(credit => {\r\n        const debitDate = new Date(debit.date);\r\n        const creditDate = new Date(credit.date);\r\n        const diff = Math.abs(debitDate.getTime() - creditDate.getTime()) / (1000 * 60 * 60 * 24);\r\n        totalDiff += diff;\r\n        count++;\r\n      });\r\n    });\r\n\r\n    return count > 0 ? totalDiff / count : Infinity;\r\n  }\r\n\r\n  /**\r\n   * Vérifie s'il y a une référence commune\r\n   */\r\n  private static hasMatchingReference(debits: AccountingEntry[], credits: AccountingEntry[], exactMatch: boolean): boolean {\r\n    for (const debit of debits) {\r\n      for (const credit of credits) {\r\n        if (exactMatch) {\r\n          if (debit.reference && credit.reference && debit.reference === credit.reference) {\r\n            return true;\r\n          }\r\n        } else {\r\n          if (this.referencesMatch(debit.reference, credit.reference)) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Vérifie si les références correspondent (recherche floue)\r\n   */\r\n  private static referencesMatch(ref1: string, ref2: string): boolean {\r\n    if (!ref1 || !ref2) return false;\r\n    \r\n    const clean1 = ref1.replace(/[^\\w]/g, '').toLowerCase();\r\n    const clean2 = ref2.replace(/[^\\w]/g, '').toLowerCase();\r\n    \r\n    if (clean1.includes(clean2) || clean2.includes(clean1)) return true;\r\n    \r\n    // Recherche de numéros communs\r\n    const numbers1 = clean1.match(/\\d{3,}/g) || [];\r\n    const numbers2 = clean2.match(/\\d{3,}/g) || [];\r\n    \r\n    return numbers1.some(n1 => numbers2.some(n2 => n1 === n2));\r\n  }\r\n\r\n  /**\r\n   * Vérifie s'il y a un tiers commun\r\n   */\r\n  private static hasMatchingThirdParty(debits: AccountingEntry[], credits: AccountingEntry[]): boolean {\r\n    for (const debit of debits) {\r\n      for (const credit of credits) {\r\n        if (debit.thirdParty && credit.thirdParty && debit.thirdParty === credit.thirdParty) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Génère un code de lettrage unique\r\n   */\r\n  private static generateLetterCode(): string {\r\n    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    let code = '';\r\n    \r\n    for (let i = 0; i < 3; i++) {\r\n      code += letters.charAt(Math.floor(Math.random() * letters.length));\r\n    }\r\n    \r\n    const numbers = Math.floor(Math.random() * 1000).toString().padStart(3, '0');\r\n    return `${code}${numbers}`;\r\n  }\r\n\r\n  /**\r\n   * Applique le lettrage à un match\r\n   */\r\n  private static async applyLetterage(match: LetterageMatch): Promise<void> {\r\n    const allEntries = [...match.debitEntries, ...match.creditEntries];\r\n    \r\n    await supabase\r\n      .from('journal_entry_items')\r\n      .update({ letterage: match.letterCode })\r\n      .in('id', allEntries);\r\n  }\r\n\r\n  /**\r\n   * Récupère les règles de lettrage (par défaut + personnalisées)\r\n   */\r\n  private static async getLetterageRules(companyId: string): Promise<LetterageRule[]> {\r\n    const customRules = await supabase\r\n      .from('letterage_rules')\r\n      .select('*')\r\n      .eq('company_id', companyId);\r\n\r\n    const rules = [...this.DEFAULT_RULES];\r\n    \r\n    if (customRules.data) {\r\n      rules.push(...customRules.data.map(this.mapSupabaseToRule));\r\n    }\r\n\r\n    return rules;\r\n  }\r\n\r\n  /**\r\n   * Mapping des données Supabase vers LetterageRule\r\n   */\r\n  private static mapSupabaseToRule(data: Record<string, unknown>): LetterageRule {\r\n    return {\r\n      id: data.id as string,\r\n      name: data.name as string,\r\n      accountPattern: data.account_pattern as string,\r\n      criteria: (data.criteria as LetterageCriteria[]) || [],\r\n      tolerance: (data.tolerance as number) || 0.01,\r\n      autoValidate: (data.auto_validate as boolean) || false\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Vérifie si un pattern correspond\r\n   */\r\n  private static matchesPattern(pattern: string, account: string): boolean {\r\n    const regex = new RegExp(`^${  pattern.replace('%', '.*')  }$`);\r\n    return regex.test(account);\r\n  }\r\n\r\n  /**\r\n   * Dé-lettrage manuel\r\n   */\r\n  static async unletter(companyId: string, letterCode: string): Promise<{\r\n    success: boolean;\r\n    unletteredCount: number;\r\n  }> {\r\n    const result = await supabase\r\n      .from('journal_entry_items')\r\n      .update({ letterage: null })\r\n      .eq('letterage', letterCode)\r\n      .eq('journal_entries.company_id', companyId)\r\n      .select('id');\r\n\r\n    return {\r\n      success: !result.error,\r\n      unletteredCount: result.data?.length || 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Rapport de lettrage\r\n   */\r\n  static async getLetterageReport(\r\n    companyId: string,\r\n    accountPattern?: string,\r\n    dateFrom?: string,\r\n    dateTo?: string\r\n  ): Promise<{\r\n    summary: {\r\n      totalEntries: number;\r\n      letteredEntries: number;\r\n      unletteredEntries: number;\r\n      letterageRate: number;\r\n    };\r\n    byAccount: Array<{\r\n      accountNumber: string;\r\n      accountName: string;\r\n      totalEntries: number;\r\n      lettered: number;\r\n      unlettered: number;\r\n      rate: number;\r\n    }>;\r\n    recentLettering: Array<{\r\n      letterCode: string;\r\n      date: string;\r\n      entriesCount: number;\r\n      totalAmount: number;\r\n    }>;\r\n  }> {\r\n    // Statistiques globales\r\n    let query = supabase\r\n      .from('journal_entry_items')\r\n      .select(`\r\n        id,\r\n        letterage,\r\n        debit_amount,\r\n        credit_amount,\r\n        accounts!inner (number, name),\r\n        journal_entries!inner (date, company_id)\r\n      `)\r\n      .eq('journal_entries.company_id', companyId);\r\n\r\n    if (accountPattern) {\r\n      query = query.like('accounts.number', accountPattern.replace('%', '*'));\r\n    }\r\n    if (dateFrom) query = query.gte('journal_entries.date', dateFrom);\r\n    if (dateTo) query = query.lte('journal_entries.date', dateTo);\r\n\r\n    const result = await query;\r\n    \r\n    if (!result.data) {\r\n      throw new Error('Erreur lors de la récupération des données');\r\n    }\r\n\r\n    const totalEntries = result.data.length;\r\n    const letteredEntries = result.data.filter(item => item.letterage).length;\r\n    const unletteredEntries = totalEntries - letteredEntries;\r\n    const letterageRate = totalEntries > 0 ? (letteredEntries / totalEntries) * 100 : 0;\r\n\r\n    // Statistiques par compte\r\n    const accountStats = new Map<string, { accountNumber: string; accountName: string; totalEntries: number; lettered: number }>();\r\n\r\n    result.data.forEach((item: AccountingEntry) => {\r\n      const accounts = item.accounts as { number?: string; name?: string };\r\n      const key = `${accounts?.number}|${accounts?.name}`;\r\n      if (!accountStats.has(key)) {\r\n        accountStats.set(key, {\r\n          accountNumber: accounts?.number || '',\r\n          accountName: accounts?.name || '',\r\n          totalEntries: 0,\r\n          lettered: 0\r\n        });\r\n      }\r\n\r\n      const stats = accountStats.get(key)!;\r\n      stats.totalEntries++;\r\n      if (item.letterage) stats.lettered++;\r\n    });\r\n\r\n    const byAccount = Array.from(accountStats.values()).map(stats => ({\r\n      ...stats,\r\n      unlettered: stats.totalEntries - stats.lettered,\r\n      rate: stats.totalEntries > 0 ? (stats.lettered / stats.totalEntries) * 100 : 0\r\n    }));\r\n\r\n    // Lettrages récents\r\n    const recentQuery = await supabase\r\n      .from('journal_entry_items')\r\n      .select(`\r\n        letterage,\r\n        debit_amount,\r\n        credit_amount,\r\n        journal_entries!inner (date, company_id)\r\n      `)\r\n      .eq('journal_entries.company_id', companyId)\r\n      .not('letterage', 'is', null)\r\n      .gte('journal_entries.date', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())\r\n      .order('journal_entries.date', { ascending: false });\r\n\r\n    const recentLettering: LetterGroup[] = [];\r\n    if (recentQuery.data) {\r\n      const letterGroups = new Map<string, LetterGroup>();\r\n\r\n      recentQuery.data.forEach((item: AccountingEntry) => {\r\n        const key = item.letterage!;\r\n        if (!letterGroups.has(key)) {\r\n          letterGroups.set(key, {\r\n            letterCode: key,\r\n            date: (item.journal_entries as { date?: string })?.date || '',\r\n            entriesCount: 0,\r\n            totalAmount: 0\r\n          });\r\n        }\r\n\r\n        const group = letterGroups.get(key)!;\r\n        group.entriesCount++;\r\n        group.totalAmount += (item.debit_amount || 0) + (item.credit_amount || 0);\r\n      });\r\n      \r\n      recentLettering.push(...Array.from(letterGroups.values()).slice(0, 10));\r\n    }\r\n\r\n    return {\r\n      summary: {\r\n        totalEntries,\r\n        letteredEntries,\r\n        unletteredEntries,\r\n        letterageRate: Math.round(letterageRate * 100) / 100\r\n      },\r\n      byAccount,\r\n      recentLettering\r\n    };\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-var-requires","replacedBy":["@typescript-eslint/no-require-imports"],"info":{"deprecatedSince":"8.0.0","replacedBy":[{"rule":{"name":"@typescript-eslint/no-require-imports","url":"https://typescript-eslint.io/rules/no-require-imports"}}],"url":"https://github.com/typescript-eslint/typescript-eslint/pull/8334"}},{"ruleId":"arrow-spacing","replacedBy":["@stylistic/arrow-spacing"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"10.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"arrow-spacing","url":"https://eslint.style/rules/arrow-spacing"}}]}}]}]
